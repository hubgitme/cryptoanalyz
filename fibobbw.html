<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>ØªØ­Ù„ÛŒÙ„ Ø²Ù†Ø¯Ù‡ Ùˆ ÙÛŒØ¨ÙˆÙ†Ø§Ú†ÛŒ (Ø¨Ø§ Ù‡Ø´Ø¯Ø§Ø± Ú©Ø±Ø§Ø³ Ø¨Ø§Ù†Ø¯ Ù…ÛŒØ§Ù†ÛŒ)</title>
<style>
body { background:#111; color:#eee; font-family:sans-serif; padding:12px; text-align:center; }
h1,h2 { color:#00ff99; margin-bottom:10px; font-size:12px;}
.table-container { overflow-x:auto; margin-top:10px; }
table { border-collapse:collapse; min-width:100%; font-size:12px; margin-bottom:30px; }
th, td { border:1px solid #333; padding:4px; text-align:center; white-space:nowrap; }
th { background:#1c1c1c; color:#0ff; font-weight:bold; }

.buy { color:#0f0; font-weight:bold; }
.sell { color:#f33; font-weight:bold; }
.neutral { color:#ccc; font-weight:bold; }
.tick.green { color:#0f0; font-weight:bold; }
.tick.red { color:#f33; font-weight:bold; }

.rsi { color:#ab47bc; }
.cci { color:#089981; }
.roc { color:#2962FF; }
.ema7 { color:#2962FF; }
.bollUpper, .bollMid, .bollLower { color:#dbdbdb; }

table tbody td:nth-child(odd):not(:first-child) { background-color: #3b3b3b; }
table tbody td:nth-child(even):not(:first-child) { background-color: #2a2a2a; }

a.tv { color:#0ff; text-decoration:none; }
select, button { background: #222; color: white; border: 1px solid #555; border-radius:6px; padding:6px; margin:4px; cursor:pointer;}
button { background:#0078ff; border:none; }
button:hover { background:#005ad1; }

/* Ø§Ø³ØªØ§ÛŒÙ„ Ø¬Ø¯ÛŒØ¯ Ø¨Ø±Ø§ÛŒ Ø¯Ú©Ù…Ù‡â€ŒÙ‡Ø§ÛŒ ØªØ§ÛŒÙ…â€ŒÙØ±ÛŒÙ… ÙÛŒØ¨ÙˆÙ†Ø§Ú†ÛŒ */
.fibo-tf-selector button {
    background: #2a2a2a;
    color: #0ff;
    border: 1px solid #0ff;
    margin: 4px 6px;
    padding: 8px 10px;
}
.fibo-tf-selector button.active {
    background: #0078ff;
    color: white;
    border-color: #0078ff;
}
</style>
</head>
<body>

<h1>ØªØ­Ù„ÛŒÙ„ Ø²Ù†Ø¯Ù‡ Ú†Ù†Ø¯ ØªØ§ÛŒÙ…â€ŒÙØ±ÛŒÙ… + ÙÛŒØ¨ÙˆÙ†Ø§Ú†ÛŒ</h1>

<div id="homeLink" style="margin: 20px; text-align: center;">
  <a href="index.html" 
     style="color:#0ff; font-size:16px; font-weight:bold; text-decoration:none;">
Ø¨Ø±Ú¯Ø´Øª Ø¨Ù‡ ØµÙØ­Ù‡ Ø§ØµÙ„ÛŒ
</a>
</div>

<p id="crossoverStatus" style="margin-top:15px; font-weight:bold; font-size:14px;">
    âœ… Ø¯Ø± Ø­Ø§Ù„ Ù†Ø¸Ø§Ø±Øª Ø¨Ø± Ú©Ø±Ø§Ø³ Ø¨Ø§Ù†Ø¯ Ù…ÛŒØ§Ù†ÛŒ Ø¨ÙˆÙ„ÛŒÙ†Ú¯Ø±.
</p>

<label for="symbolSelect">Ø§Ù†ØªØ®Ø§Ø¨ Ø§Ø±Ø²:</label>
<select id="symbolSelect">
  <option selected>BLUMUSDT</option>
  <option>BTCUSDT</option>
  <option>ETHUSDT</option>
  <option>SOLUSDT</option>
  <option>SUIUSDT</option>
  <option>XRPUSDT</option>
  <option>NEARUSDT</option>
  <option>CAKEUSDT</option>
  <option>ASTERUSDT</option>
  <option>ADAUSDT</option>
  <option>CRVUSDT</option>
  <option>XLMUSDT</option>
  <option>DOGEUSDT</option>
  <option>TRXUSDT</option>
  <option>PUMPUSDT</option>
  <option>TONUSDT</option>
</select>

<div class="table-container">
<table>
<thead>
<tr>
<th>TF / INDIC</th>
<th>1h</th>
<th>4h</th>
<th>8h</th>
<th>1d</th>
<th>1W</th>
</tr>
</thead>
<tbody id="tableBody">
<tr><td colspan="7">Ø¯Ø± Ø­Ø§Ù„ Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§...</td></tr>
</tbody>
</table>
</div>

<h2>ÙÛŒØ¨ÙˆÙ†Ø§Ú†ÛŒ</h2>

<div class="fibo-tf-selector" id="fiboTfSelector">
  <button data-tf="60m" data-limit="144">1 Ø³Ø§Ø¹ØªÙ‡ (144)</button>
  <button data-tf="4h" data-limit="144" class="active">4 Ø³Ø§Ø¹ØªÙ‡ (144)</button>
  <button data-tf="1d" data-limit="200">Ø±ÙˆØ²Ø§Ù†Ù‡ (200)</button>
</div>

<p id="statusFibo">Ø¯Ø± Ø­Ø§Ù„ Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§...</p>

<table id="fiboTable">
<thead>
<tr><th>Ø¯Ø±ØµØ¯ (%)</th><th>Ø³Ø·Ø­ ÙÛŒØ¨ÙˆÙ†Ø§Ú†ÛŒ</th></tr>
</thead>
<tbody id="fiboBody"></tbody>
</table>

<script>
//================ Ø¬Ø¯ÙˆÙ„ Ø§ÙˆÙ„ (HA + Ø§Ù†Ø¯ÛŒÚ©Ø§ØªÙˆØ±Ù‡Ø§) =================
const intervals = ["60m","4h","8h","1d","1W"];
let currentSymbol = document.getElementById('symbolSelect').value;
// Ù…ØªØºÛŒØ± Ø¬Ø¯ÛŒØ¯ Ø¨Ø±Ø§ÛŒ Ù†Ú¯Ù‡Ø¯Ø§Ø±ÛŒ ØªØ§ÛŒÙ… ÙØ±ÛŒÙ… ÙÛŒØ¨ÙˆÙ†Ø§Ú†ÛŒ Ø§Ù†ØªØ®Ø§Ø¨ Ø´Ø¯Ù‡
let currentFiboTF = '4h'; // Ù…Ù‚Ø¯Ø§Ø± Ù¾ÛŒØ´â€ŒÙØ±Ø¶

// === Ø§Ø¨Ø²Ø§Ø±Ù‡Ø§ÛŒ Ù‡Ø´Ø¯Ø§Ø± Ø¬Ø¯ÛŒØ¯ ===
let isCrossoverActive = false;
const alertSound = new Audio('https://s3.tradingview.com/static/notify/notification.mp3');

function requestNotificationPermission() {
    if ('Notification' in window) {
        if (Notification.permission !== 'granted' && Notification.permission !== 'denied') {
            Notification.requestPermission();
        }
    }
}

function playAudio() {
    try {
        alertSound.currentTime = 0; 
        alertSound.play().catch(e => console.error("Audio playback restricted:", e));
    } catch(e) {
        console.error("Audio playback failed:", e);
    }
}

function vibrateDevice() {
    if ('vibrate' in navigator) {
        navigator.vibrate([200, 100, 200]);
    }
}

function sendDesktopNotification(title, body) {
    if ('Notification' in window && Notification.permission === 'granted') {
        new Notification(title, { 
            body: body, 
            icon: 'https://www.google.com/s2/favicons?domain=tradingview.com',
            vibrate: [200, 100, 200]
        });
    }
}

function checkForBollingerCrossoverAlert(currentClose, prevClose, midBand, interval) {
    let alertMessage = null;
    const title = `${currentSymbol} ${interval} - Ù‡Ø´Ø¯Ø§Ø± Ú©Ø±Ø§Ø³ Ø¨Ø§Ù†Ø¯ Ù…ÛŒØ§Ù†ÛŒ`;

    const bullishCrossover = (prevClose < midBand) && (currentClose > midBand);
    const bearishCrossover = (prevClose > midBand) && (currentClose < midBand);

    if (midBand === null) return; 

    if (bullishCrossover) {
        alertMessage = `â¬†ï¸ Ú©Ø±Ø§Ø³ ØµØ¹ÙˆØ¯ÛŒ: Ú©Ù†Ø¯Ù„ Ø¨Ù‡ Ø¨Ø§Ù„Ø§ÛŒ Ø¨Ø§Ù†Ø¯ Ù…ÛŒØ§Ù†ÛŒ (${midBand.toFixed(5)}) Ø¨Ø³ØªÙ‡ Ø´Ø¯.`;
    } else if (bearishCrossover) {
        alertMessage = `â¬‡ï¸ Ú©Ø±Ø§Ø³ Ù†Ø²ÙˆÙ„ÛŒ: Ú©Ù†Ø¯Ù„ Ø¨Ù‡ Ø²ÛŒØ± Ø¨Ø§Ù†Ø¯ Ù…ÛŒØ§Ù†ÛŒ (${midBand.toFixed(5)}) Ø¨Ø³ØªÙ‡ Ø´Ø¯.`;
    }

    if (alertMessage && !isCrossoverActive) {
        isCrossoverActive = true;
        
        playAudio();
        vibrateDevice();
        sendDesktopNotification(title, alertMessage);

        const statusEl = document.getElementById('crossoverStatus');
        if (statusEl) {
            statusEl.innerHTML = `ğŸš¨ **ALERT:** ${alertMessage} ğŸš¨`;
            statusEl.classList.add(bullishCrossover ? 'buy' : 'sell');
        }
        
        setTimeout(() => {
            isCrossoverActive = false;
            if (statusEl) {
                statusEl.textContent = 'âœ… Ø¯Ø± Ø­Ø§Ù„ Ù†Ø¸Ø§Ø±Øª Ø¨Ø± Ú©Ø±Ø§Ø³ Ø¨Ø§Ù†Ø¯ Ù…ÛŒØ§Ù†ÛŒ Ø¨ÙˆÙ„ÛŒÙ†Ú¯Ø±.';
                statusEl.classList.remove('buy', 'sell');
            }
        }, 60000); 
    }
}
// === Ù¾Ø§ÛŒØ§Ù† Ø§Ø¨Ø²Ø§Ø±Ù‡Ø§ÛŒ Ù‡Ø´Ø¯Ø§Ø± Ø¬Ø¯ÛŒØ¯ ===


async function fetchPrices(symbol, interval="60m"){
  try{
    const url=`https://api.mexc.com/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=200`; 
    const proxy="https://corsproxy.io/?";
    const res=await fetch(proxy+encodeURIComponent(url));
    const data=await res.json();
    return data.map(c=>({time:new Date(c[0]), open:+c[1], high:+c[2], low:+c[3], close:+c[4]}));
  }catch(e){ console.error(e); return null; }
}

function convertHA(data){
  if(!data) return [];
  const ha=[];
  for(let i=0;i<data.length;i++){
    const {open:o,high:h,low:l,close:c}=data[i];
    if(i===0) ha.push({open:(o+c)/2, high:h, low:l, close:(o+h+l+c)/4});
    else{
      const prev=ha[i-1];
      const haClose=(o+h+l+c)/4;
      ha.push({open:(prev.open+prev.close)/2, high:Math.max(h,(prev.open+prev.close)/2,haClose), low:Math.min(l,(prev.open+prev.close)/2,haClose), close:haClose});
    }
  }
  return ha;
}

function calculateEMAArray(values, period){
  if(!values||values.length<period) return Array(values?values.length:0).fill(null);
  const k=2/(period+1), out=[]; let sum=0;
  for(let i=0;i<values.length;i++){
    const v=values[i];
    if(i<period-1){ out.push(null); sum+=v||0; continue; }
    if(i===period-1){ sum+=v||0; out.push(sum/period); continue; }
    const prev=out[i-1]; const val=v==null?prev:v; out.push(val*k + prev*(1-k));
  }
  return out;
}

function calculateMA(values, period){
  if(!values || values.length<period) return [];
  const ma=[];
  for(let i=0;i<values.length;i++){
    if(i<period-1||values[i]==null) ma.push(null);
    else { const slice=values.slice(i-period+1,i+1).filter(v=>v!=null); ma.push(slice.reduce((a,b)=>a+b,0)/slice.length); }
  }
  return ma;
}

function calculateRSI(data, period=14) {
  const closes = data.map(d=>d.close);
  if (closes.length <= period) return Array(closes.length).fill(null);
  let gains=0, losses=0;
  for (let i=1;i<=period;i++){
    const diff=closes[i]-closes[i-1];
    if(diff>=0) gains+=diff; else losses-=diff;
  }
  let avgGain=gains/period, avgLoss=losses/period;
  const rsi = Array(period).fill(null);
  for (let i=period;i<closes.length;i++){
    if(i>period){
      const diff=closes[i]-closes[i-1];
      if(diff>=0){ avgGain=(avgGain*(period-1)+diff)/period; avgLoss=(avgLoss*(period-1)+0)/period;}
      else{ avgGain=(avgGain*(period-1)+0)/period; avgLoss=(avgLoss*(period-1)+(-diff))/period;}
    }
    const rs = avgLoss===0?100:avgGain/avgLoss;
    rsi.push(100-(100/(1+rs)));
  }
  return rsi;
}

function calculateCCI(data, period=14){
  if(!data||data.length<period) return Array(data.length).fill(null);
  const cci=[];
  for(let i=0;i<data.length;i++){
    if(i<period-1){ cci.push(null); continue;}
    const slice=data.slice(i-period+1,i+1);
    const tp=slice.map(d=>(d.high+d.low+d.close)/3);
    const sma=tp.reduce((a,b)=>a+b,0)/period;
    const meanDev=tp.reduce((a,b)=>a+Math.abs(b-sma),0)/period;
    const currentTP=(data[i].high+data[i].low+data[i].close)/3;
    cci.push((currentTP-sma)/(0.015*meanDev));
  }
  return cci;
}

function calculateBollinger(data, period=14){
  if(!data||data.length<period) return {upper:[], mid:[], lower:[]};
  const mid=[]; for(let i=period-1;i<data.length;i++){ const slice=data.slice(i-period+1,i+1).map(d=>d.close); mid.push(slice.reduce((a,b)=>a+b,0)/period);}
  const upper=[], lower=[];
  for(let i=period-1;i<data.length;i++){
    const slice=data.slice(i-period+1,i+1).map(d=>d.close);
    const avg=mid[i-(period-1)];
    const std=Math.sqrt(slice.map(p=>Math.pow(p-avg,2)).reduce((a,b)=>a+b,0)/period);
    upper.push(avg+2*std); lower.push(avg-2*std);
  }
  return {upper, mid, lower};
}

function calculateROC(prices, period=9){
  if(!prices||prices.length<period) return [];
  return prices.map((p,i)=>i<period?null:(p.close-prices[i-period].close)/prices[i-period].close*100);
}

function getTickHtml(cond){ return cond?'<span class="tick green">âœ”</span>':'<span class="tick red">âœ˜</span>'; }

async function getSymbolData(symbol, interval){
  const raw = await fetchPrices(symbol, interval);
  if(!raw||raw.length===0) return null;
  const ha=convertHA(raw);
  
  const price=raw.at(-1)?.close;
  const prevClose=raw.at(-2)?.close;
  
  const ema7 = raw.length >= 7 ? calculateEMAArray(raw.map(d=>d.close),7) : Array(raw.length).fill(null);

  const boll=ha.length>=14?calculateBollinger(ha):{upper:Array(ha.length).fill(null), mid:Array(ha.length).fill(null), lower:Array(ha.length).fill(null)};
  const rsi=ha.length>=14?calculateRSI(ha):Array(ha.length).fill(null);
  const rsiMA=rsi.length>=14?calculateMA(rsi,14):Array(rsi.length).fill(null);
  const cci=ha.length>=14?calculateCCI(ha):Array(ha.length).fill(null);
  const cciMA=cci.length>=14?calculateMA(cci,14):Array(cci.length).fill(null);
  const roc=ha.length>=9?calculateROC(ha,9):Array(ha.length).fill(null);
  const rocMA=roc.length>=5?calculateMA(roc,5):Array(ha.length).fill(null);
  const prevcci=cci.length>=2?cci.at(-2):null;
  const latest={
    bollUpper:boll.upper.at(-1), bollMid:boll.mid.at(-1), bollLower:boll.lower.at(-1),
    rsi:rsi.at(-1), rsiMA:rsiMA.at(-1),
    cci:cci.at(-1), cciMA:cciMA.at(-1),
    roc:roc.at(-1), rocMA:rocMA.at(-1),
    ema7: ema7.at(-1)
  };
  let buy=false, sell=false;
  if([price, latest.bollMid, latest.rsi, latest.rsiMA, latest.cci].every(v=>v!=null)){
    buy=price>latest.bollMid && latest.rsi>latest.rsiMA && prevcci<0 && latest.cci>0;
    sell=price<latest.bollMid && latest.rsi<latest.rsiMA && prevcci>0 && latest.cci<0;
  }
  return {...latest, symbol, price, prevClose, buySignal:buy, sellSignal:sell}; 
}

function buildReversedTable(){
  const tbody=document.getElementById('tableBody');
  tbody.innerHTML='';
  const indicators=["price","ema7","bollMid","bollUpper","bollLower","rsi","rsiMA","cci","cciMA","roc","rocMA","signal","tv"];
  for(const ind of indicators){
    const tr=document.createElement('tr');
    tr.id=`row_${ind}`;
    tr.innerHTML=`<td>${ind.toUpperCase()}</td>`+intervals.map(i=>`<td id="${ind}_${i}">â€”</td>`).join('');
    tbody.appendChild(tr);
  }
}

async function updateReversedTable(){
  for(const interval of intervals){
    const data=await getSymbolData(currentSymbol, interval);
    if(!data) continue;
    
    // --- Ø§Ø¬Ø±Ø§ÛŒ Ø¨Ø±Ø±Ø³ÛŒ Ù‡Ø´Ø¯Ø§Ø± Ú©Ø±Ø§Ø³ Ø¨Ø§Ù†Ø¯ Ù…ÛŒØ§Ù†ÛŒ Ø¨Ø±Ø§ÛŒ ØªØ§ÛŒÙ…â€ŒÙØ±ÛŒÙ…â€ŒÙ‡Ø§ÛŒ Û± Ùˆ Û´ Ø³Ø§Ø¹ØªÙ‡ ---
    if(interval === '60m' || interval === '4h') { 
        if (data.price && data.prevClose && data.bollMid) {
             checkForBollingerCrossoverAlert(data.price, data.prevClose, data.bollMid, interval);
        }
    }
    // ----------------------------------
    
    const mapData={
      price:data.price?.toFixed(5)??'â€”',
      ema7: `${data.ema7?.toFixed(5) ?? 'â€”'} ${getTickHtml(data.price>data.ema7)}`,
      bollMid:`${data.bollMid?.toFixed(5)??'â€”'} ${getTickHtml(data.price>data.bollMid)}`,
      bollUpper:data.bollUpper?.toFixed(5)??'â€”',
      bollLower:data.bollLower?.toFixed(5)??'â€”',
      rsi:`${data.rsi?.toFixed(2)??'â€”'} ${getTickHtml(data.rsi>data.rsiMA)}`,
      rsiMA:data.rsiMA?.toFixed(2)??'â€”',
      cci:`${data.cci?.toFixed(2)??'â€”'} ${getTickHtml(data.cci>0)}`,
      cciMA:data.cciMA?.toFixed(2)??'â€”',
      roc:`${data.roc?.toFixed(2)??'â€”'} ${getTickHtml(data.roc>data.rocMA)}`,
      rocMA:data.rocMA?.toFixed(2)??'â€”',
      signal:data.buySignal?'Ø®Ø±ÛŒØ¯ âœ…':data.sellSignal?'ÙØ±ÙˆØ´ âŒ':'Ø®Ù†Ø«ÛŒ',
      tv:`<a class="tv" href="https://www.tradingview.com/chart/?symbol=BINANCE:${currentSymbol}" target="_blank">Ù…Ø´Ø§Ù‡Ø¯Ù‡</a>`
    };
    for(const key in mapData){
      const td=document.getElementById(`${key}_${interval}`);
      if(td) td.innerHTML=mapData[key];
    }
  }
}

document.getElementById('symbolSelect').addEventListener('change', e=>{
  currentSymbol=e.target.value;
  buildReversedTable();
  updateReversedTable();
  updateFibo();
});

// === Ø§Ø¬Ø±Ø§ÛŒ Ø§ÙˆÙ„ÛŒÙ‡ Ùˆ Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ù…Ø¬ÙˆØ² Ø§Ø¹Ù„Ø§Ù†â€ŒÙ‡Ø§ ===
document.addEventListener('DOMContentLoaded', () => {
    requestNotificationPermission();

    buildReversedTable();
    updateReversedTable();
    createFiboTable(); // Ø¬Ø¯ÙˆÙ„ ÙÛŒØ¨Ùˆ Ø±Ø§ ÛŒÚ©Ø¨Ø§Ø± Ø¨Ø³Ø§Ø²
    updateFibo();
});

// Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø®ÙˆØ¯Ú©Ø§Ø±
setInterval(updateReversedTable,30000);

//================ Ø¬Ø¯ÙˆÙ„ ÙÛŒØ¨ÙˆÙ†Ø§Ú†ÛŒ (Ø¨Ø§ Ù…Ù†Ø·Ù‚ Ø¬Ø¯ÛŒØ¯) =================
function getColorByLevel(lvl){
  if(lvl===0.5) return "white";
  if(lvl>0.5){ const t=(lvl-0.5)/0.5; const r=255,g=Math.floor(255-t*155),b=Math.floor(255-t*155); return `rgb(${r},${g},${b})`; }
  else{ const t=lvl/0.5; const r=255,g=Math.floor(255*t),b=0; return `rgb(${r},${g},${b})`; }
}

function createFiboTable(){
  const levels=[0,0.236,0.382,0.5,0.618,0.786,1];
  const tbody=document.getElementById("fiboBody");
  tbody.innerHTML="";
  levels.forEach(lvl=>{
    const tr=document.createElement("tr");
    tr.style.color=getColorByLevel(lvl);
    const td1=document.createElement("td"); td1.textContent=(lvl*100).toFixed(1)+"%";
    const td2=document.createElement("td"); td2.id="lvl_"+lvl.toString().replace(".","_");
    tr.appendChild(td1); tr.appendChild(td2);
    tbody.appendChild(tr);
  });
}

async function updateFibo(){
  const tf = currentFiboTF; 
  const symbol=document.getElementById("symbolSelect").value;
  
  // ØªØ¹ÛŒÛŒÙ† limit Ø¨Ø± Ø§Ø³Ø§Ø³ Ø¯Ú©Ù…Ù‡â€ŒÙ‡Ø§ÛŒ HTML
  const activeBtn = document.querySelector(`.fibo-tf-selector button[data-tf="${tf}"].active`);
  let limit = activeBtn ? parseInt(activeBtn.getAttribute('data-limit')) : 200; // Ù¾ÛŒØ´â€ŒÙØ±Ø¶ 200
  
  const proxy="https://corsproxy.io/?";
  const url=`https://api.mexc.com/api/v3/klines?symbol=${symbol}&interval=${tf}&limit=${limit}`;
  document.getElementById("statusFibo").textContent=`â³ Ø¯Ø± Ø­Ø§Ù„ Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ ${tf} (${limit} Ú©Ù†Ø¯Ù„)...`;
  
  try{
    const res=await fetch(proxy+encodeURIComponent(url));
    const data=await res.json();
    
    if(!Array.isArray(data)||data.length<2) throw new Error("Ø¯Ø§Ø¯Ù‡ Ú©Ø§ÙÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯");
    
    const levels=[0,0.236,0.382,0.5,0.618,0.786,1];
    
    // Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù‚ÛŒÙ…Øªâ€ŒÙ‡Ø§ÛŒ High Ùˆ Low Ø¨Ù‡ ØµÙˆØ±Øª Ø¢Ø±Ø§ÛŒÙ‡ Ø§Ø² API
    const highsC=data.map(d=>parseFloat(d[2]));
    const lowsC=data.map(d=>parseFloat(d[3]));
    
    let highC=Math.max(...highsC);
    let lowC=Math.min(...lowsC);

    // --- Ù…Ù†Ø·Ù‚ Ø¬Ø¯ÛŒØ¯ Ø¨Ø±Ø§ÛŒ Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² High Ùˆ Low Ø¯Ø± ÛŒÚ© Ú©Ù†Ø¯Ù„ ---
    
    let highIndex = -1;
    let lowIndex = -1;
    
    // ÛŒØ§ÙØªÙ† Ø§Ù†Ø¯ÛŒØ³ (Ø´Ù…Ø§Ø±Ù‡ Ú©Ù†Ø¯Ù„) Ù…Ø±Ø¨ÙˆØ· Ø¨Ù‡ High Ùˆ Low
    // Ø§Ø² Ø§Ù†ØªÙ‡Ø§ Ø´Ø±ÙˆØ¹ Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ… ØªØ§ Ø¬Ø¯ÛŒØ¯ØªØ±ÛŒÙ† ÙˆÙ‚ÙˆØ¹ Ø±Ø§ Ø¨Ú¯ÛŒØ±ÛŒÙ…
    for (let i = data.length - 1; i >= 0; i--) {
        if (highIndex === -1 && parseFloat(data[i][2]) === highC) {
            highIndex = i;
        }
        if (lowIndex === -1 && parseFloat(data[i][3]) === lowC) {
            lowIndex = i;
        }
        if (highIndex !== -1 && lowIndex !== -1) {
            break; 
        }
    }
    
    // Ø§Ú¯Ø± High Ùˆ Low Ø¯Ø± ÛŒÚ© Ú©Ù†Ø¯Ù„ Ù‚Ø±Ø§Ø± Ø¯Ø§Ø´ØªÙ†Ø¯
    if (highIndex === lowIndex && highIndex !== -1) {
        
        // Ù…Ø§ Low Ø±Ø§ Ù†Ø§Ø¯ÛŒØ¯Ù‡ Ú¯Ø±ÙØªÙ‡ Ùˆ Low Ø¬Ø¯ÛŒØ¯ Ø±Ø§ Ø§Ø² Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ù‚ÛŒâ€ŒÙ…Ø§Ù†Ø¯Ù‡ Ù¾ÛŒØ¯Ø§ Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ…
        // ØªÙ…Ø§Ù… High Ùˆ Low Ù‡Ø§ÛŒ Ø¯ÛŒÚ¯Ø± Ø±Ø§ Ø¨Ù‡ Ø¬Ø² High/Low Ú©Ù†Ø¯Ù„ ÙØ¹Ù„ÛŒ Ø¯Ø± Ù†Ø¸Ø± Ù…ÛŒâ€ŒÚ¯ÛŒØ±ÛŒÙ….
        let filteredPrices = [];
        for (let i = 0; i < data.length; i++) {
            if (i !== highIndex) {
                 filteredPrices.push(parseFloat(data[i][3])); // Lows
            }
        }
        
        if (filteredPrices.length > 0) {
            lowC = Math.min(...filteredPrices); // Low Ø¬Ø¯ÛŒØ¯ Ø±Ø§ Ø§Ø² Ù…ÛŒØ§Ù† Ø³Ø§ÛŒØ± Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§ Ù¾ÛŒØ¯Ø§ Ú©Ù†.
        } else {
            // Ø§Ú¯Ø± Ø¨Ø¹Ø¯ Ø§Ø² ÙÛŒÙ„ØªØ±ØŒ Ø¯Ø§Ø¯Ù‡â€ŒØ§ÛŒ Ù†Ù…Ø§Ù†Ø¯ ÛŒØ§ ÙÙ‚Ø· ÛŒÚ© Ú©Ù†Ø¯Ù„ Ø¨Ø§Ø´Ø¯ØŒ Ø®Ø·Ø§ Ø§ÛŒØ¬Ø§Ø¯ Ú©Ù†
            lowC = highC; 
        }
    }
    
    // -----------------------------------------------------------
    
    const diffC=highC-lowC;
    
    // Ø§Ú¯Ø± Ø§Ø®ØªÙ„Ø§Ù ØµÙØ± Ø¨ÙˆØ¯ØŒ Ø³Ø·ÙˆØ­ Ø±Ø§ Ù†Ù…Ø§ÛŒØ´ Ù†Ø¯Ù‡
    if (diffC === 0) {
        levels.forEach(lvl => {
            const td=document.getElementById("lvl_"+lvl.toString().replace(".","_"));
            if(td) td.textContent = "N/A - Flat Range";
        });
        document.getElementById("statusFibo").textContent=`âš ï¸ Ø¨Ø§Ø²Ù‡ Ù†ÙˆØ³Ø§Ù† ${tf} ØµÙØ± Ø§Ø³Øª.`;
        return;
    }
    
    const lastClose=parseFloat(data[data.length-1][4]);
    const prevClose=parseFloat(data[data.length-2][4]);
    
    levels.forEach(lvl=>{
      const price=highC-diffC*lvl;
      let mark="";
      // Ø¨Ø±Ø±Ø³ÛŒ Ú©Ø±Ø§Ø³ Ø®Ø· ÙÛŒØ¨ÙˆÙ†Ø§Ú†ÛŒ
      if(prevClose<price && lastClose>price) mark="â¬†ï¸"; // Ú©Ø±Ø§Ø³ ØµØ¹ÙˆØ¯ÛŒ
      else if(prevClose>price && lastClose<price) mark="â¬‡ï¸"; // Ú©Ø±Ø§Ø³ Ù†Ø²ÙˆÙ„ÛŒ
      
      const td=document.getElementById("lvl_"+lvl.toString().replace(".","_"));
      if(td) td.innerHTML = `${price.toFixed(6)} ${mark}`;
    });
    
    document.getElementById("statusFibo").textContent=`âœ… Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ ${tf} (${limit} Ú©Ù†Ø¯Ù„) Ø¨Ø±ÙˆØ² Ø´Ø¯Ù†Ø¯: ${new Date().toLocaleTimeString()}`;
  }catch(err){
    console.error(err);
    document.getElementById("statusFibo").textContent="âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡ ÛŒØ§ Ù…Ø­Ø§Ø³Ø¨Ù‡ ÙÛŒØ¨ÙˆÙ†Ø§Ú†ÛŒ.";
  }
}

// === Ù…Ù†Ø·Ù‚ Ø¬Ø¯ÛŒØ¯ Ø¨Ø±Ø§ÛŒ Ø¯Ú©Ù…Ù‡â€ŒÙ‡Ø§ÛŒ Ø§Ù†ØªØ®Ø§Ø¨ ØªØ§ÛŒÙ…â€ŒÙØ±ÛŒÙ… ÙÛŒØ¨ÙˆÙ†Ø§Ú†ÛŒ ===
const fiboTfSelector = document.getElementById('fiboTfSelector');

fiboTfSelector.addEventListener('click', (e) => {
    if (e.target.tagName === 'BUTTON') {
        const newTf = e.target.getAttribute('data-tf');
        
        // Ø­Ø°Ù Ú©Ù„Ø§Ø³ active Ø§Ø² Ù‡Ù…Ù‡ Ø¯Ú©Ù…Ù‡â€ŒÙ‡Ø§
        fiboTfSelector.querySelectorAll('button').forEach(btn => {
            btn.classList.remove('active');
        });
        
        // Ø§ÙØ²ÙˆØ¯Ù† Ú©Ù„Ø§Ø³ active Ø¨Ù‡ Ø¯Ú©Ù…Ù‡ Ú©Ù„ÛŒÚ© Ø´Ø¯Ù‡
        e.target.classList.add('active');
        
        // Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ù…ØªØºÛŒØ± Ø³Ø±Ø§Ø³Ø±ÛŒ Ùˆ Ø§Ø¬Ø±Ø§ÛŒ Ù…Ø­Ø§Ø³Ø¨Ù‡
        currentFiboTF = newTf;
        updateFibo();
    }
});
// === Ù¾Ø§ÛŒØ§Ù† Ù…Ù†Ø·Ù‚ Ø¬Ø¯ÛŒØ¯ ===


// Ø§Ø·Ù…ÛŒÙ†Ø§Ù† Ø§Ø² Ù…Ù‚Ø¯Ø§Ø±Ø¯Ù‡ÛŒ Ø§ÙˆÙ„ÛŒÙ‡ currentFiboTF Ø¯Ø± Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ
const initialActiveBtn = document.querySelector('.fibo-tf-selector button.active');
if (initialActiveBtn) {
    currentFiboTF = initialActiveBtn.getAttribute('data-tf');
}


createFiboTable();
setInterval(updateFibo,30000); // Ø¨Ù‡ Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø®ÙˆØ¯Ú©Ø§Ø± ÙÛŒØ¨ÙˆÙ†Ø§Ú†ÛŒ
</script>
</body>
</html>
