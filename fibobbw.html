<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>ØªØ­Ù„ÛŒÙ„ Ø²Ù†Ø¯Ù‡ Ùˆ ÙÛŒØ¨ÙˆÙ†Ø§Ú†ÛŒ</title>
<style>
body { background:#111; color:#eee; font-family:sans-serif; padding:12px; text-align:center; }
h1,h2 { color:#00ff99; margin-bottom:10px; font-size:12px;}
.table-container { overflow-x:auto; margin-top:10px; }
table { border-collapse:collapse; min-width:100%; font-size:12px; margin-bottom:30px; }
th, td { border:1px solid #333; padding:4px; text-align:center; white-space:nowrap; }
th { background:#1c1c1c; color:#0ff; font-weight:bold; }

.buy { color:#0f0; font-weight:bold; }
.sell { color:#f33; font-weight:bold; }
.neutral { color:#ccc; font-weight:bold; }
.tick.green { color:#0f0; font-weight:bold; }
.tick.red { color:#f33; font-weight:bold; }

.rsi { color:#ab47bc; }
.cci { color:#089981; }
.roc { color:#2962FF; }
.bollUpper, .bollMid, .bollLower { color:#dbdbdb; }

table tbody td:nth-child(odd):not(:first-child) { background-color: #3b3b3b; }
table tbody td:nth-child(even):not(:first-child) { background-color: #2a2a2a; }

a.tv { color:#0ff; text-decoration:none; }
select, button { background: #222; color: white; border: 1px solid #555; border-radius:6px; padding:6px; margin:4px; cursor:pointer;}
button { background:#0078ff; border:none; }
button:hover { background:#005ad1; }
</style>
</head>
<body>

<h1>ØªØ­Ù„ÛŒÙ„ Ø²Ù†Ø¯Ù‡ Ú†Ù†Ø¯ ØªØ§ÛŒÙ…â€ŒÙØ±ÛŒÙ… + ÙÛŒØ¨ÙˆÙ†Ø§Ú†ÛŒ</h1>
<!-- Ù„ÛŒÙ†Ú© Ø¨Ø±Ú¯Ø´Øª Ø¨Ù‡ ØµÙØ­Ù‡ Ø§ØµÙ„ÛŒ -->
<div id="homeLink" style="margin: 20px; text-align: center;">
  <a href="index.html" 
     style="color:#0ff; font-size:16px; font-weight:bold; text-decoration:none;">
Ø¨Ø±Ú¯Ø´Øª Ø¨Ù‡ ØµÙØ­Ù‡ Ø§ØµÙ„ÛŒ
</a>
</div>
  
<label for="symbolSelect">Ø§Ù†ØªØ®Ø§Ø¨ Ø§Ø±Ø²:</label>
<select id="symbolSelect">
  <option selected>BLUMUSDT</option>
  <option>BTCUSDT</option>
  <option>ETHUSDT</option>
  <option>SOLUSDT</option>
  <option>SUIUSDT</option>
  <option>XRPUSDT</option>
  <option>NEARUSDT</option>
  <option>CAKEUSDT</option>
  <option>ASTERUSDT</option>
  <option>ADAUSDT</option>
  <option>CRVUSDT</option>
  <option>XLMUSDT</option>
  <option>DOGEUSDT</option>
  <option>TRXUSDT</option>
  <option>PUMPUSDT</option>
  <option>TONUSDT</option>
</select>

<!-- Ø¬Ø¯ÙˆÙ„ Ø§Ù†Ø¯ÛŒÚ©Ø§ØªÙˆØ±Ù‡Ø§ -->
<div class="table-container">
<table>
<thead>
<tr>
<th>TF / INDIC</th>
<th>1h</th>
<th>4h</th>
<th>8h</th>
<th>1d</th>
<th>1W</th>
</tr>
</thead>
<tbody id="tableBody">
<tr><td colspan="7">Ø¯Ø± Ø­Ø§Ù„ Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§...</td></tr>
</tbody>
</table>
</div>

<!-- Ø¬Ø¯ÙˆÙ„ ÙÛŒØ¨ÙˆÙ†Ø§Ú†ÛŒ -->
<h2>ÙÛŒØ¨ÙˆÙ†Ø§Ú†ÛŒ</h2>
<div>
<label>ØªØ§ÛŒÙ…â€ŒÙØ±ÛŒÙ… ÙÛŒØ¨ÙˆÙ†Ø§Ú†ÛŒ:</label>
<select id="tfFibo">
  <option value="60m">1 Ø³Ø§Ø¹ØªÙ‡</option>
  <option value="4h" selected>4 Ø³Ø§Ø¹ØªÙ‡</option>
  <option value="1d">Ø±ÙˆØ²Ø§Ù†Ù‡</option>
</select>
<button onclick="updateFibo()">Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø¯Ø³ØªÛŒ</button>
</div>
<p id="statusFibo">Ø¯Ø± Ø­Ø§Ù„ Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§...</p>
<div id="infoFibo">
  <p class="info" id="fiboLength">ğŸ“ Ø·ÙˆÙ„ Ø¯ÙˆØ±Ù‡: -</p>
</div>

<table id="fiboTable">
<thead>
<tr><th>Ø¯Ø±ØµØ¯ (%)</th><th>Ø³Ø·Ø­ ÙÛŒØ¨ÙˆÙ†Ø§Ú†ÛŒ</th></tr>
</thead>
<tbody id="fiboBody"></tbody>
</table>

<script>
//================ Ø¬Ø¯ÙˆÙ„ Ø§ÙˆÙ„ (HA + Ø§Ù†Ø¯ÛŒÚ©Ø§ØªÙˆØ±Ù‡Ø§) =================
const intervals = ["60m","4h","8h","1d","1W"];
let currentSymbol = document.getElementById('symbolSelect').value;

async function fetchPrices(symbol, interval="60m"){
  try{
    const url=`https://api.mexc.com/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=15`;
    const proxy="https://corsproxy.io/?";
    const res=await fetch(proxy+encodeURIComponent(url));
    const data=await res.json();
    return data.map(c=>({time:new Date(c[0]), open:+c[1], high:+c[2], low:+c[3], close:+c[4]}));
  }catch(e){ console.error(e); return null; }
}

function convertHA(data){
  if(!data) return [];
  const ha=[];
  for(let i=0;i<data.length;i++){
    const {open:o,high:h,low:l,close:c}=data[i];
    if(i===0) ha.push({open:(o+c)/2, high:h, low:l, close:(o+h+l+c)/4});
    else{
      const prev=ha[i-1];
      const haClose=(o+h+l+c)/4;
      ha.push({open:(prev.open+prev.close)/2, high:Math.max(h,(prev.open+prev.close)/2,haClose), low:Math.min(l,(prev.open+prev.close)/2,haClose), close:haClose});
    }
  }
  return ha;
}

function calculateMA(values, period){
  if(!values || values.length<period) return [];
  const ma=[];
  for(let i=0;i<values.length;i++){
    if(i<period-1||values[i]==null) ma.push(null);
    else { const slice=values.slice(i-period+1,i+1).filter(v=>v!=null); ma.push(slice.reduce((a,b)=>a+b,0)/slice.length); }
  }
  return ma;
}

function calculateRSI(data, period=14) {
  const closes = data.map(d=>d.close);
  if (closes.length <= period) return Array(closes.length).fill(null);
  let gains=0, losses=0;
  for (let i=1;i<=period;i++){
    const diff=closes[i]-closes[i-1];
    if(diff>=0) gains+=diff; else losses-=diff;
  }
  let avgGain=gains/period, avgLoss=losses/period;
  const rsi = Array(period).fill(null);
  for (let i=period;i<closes.length;i++){
    if(i>period){
      const diff=closes[i]-closes[i-1];
      if(diff>=0){ avgGain=(avgGain*(period-1)+diff)/period; avgLoss=(avgLoss*(period-1)+0)/period;}
      else{ avgGain=(avgGain*(period-1)+0)/period; avgLoss=(avgLoss*(period-1)+(-diff))/period;}
    }
    const rs = avgLoss===0?100:avgGain/avgLoss;
    rsi.push(100-(100/(1+rs)));
  }
  return rsi;
}

function calculateCCI(data, period=14){
  if(!data||data.length<period) return Array(data.length).fill(null);
  const cci=[];
  for(let i=0;i<data.length;i++){
    if(i<period-1){ cci.push(null); continue;}
    const slice=data.slice(i-period+1,i+1);
    const tp=slice.map(d=>(d.high+d.low+d.close)/3);
    const sma=tp.reduce((a,b)=>a+b,0)/period;
    const meanDev=tp.reduce((a,b)=>a+Math.abs(b-sma),0)/period;
    const currentTP=(data[i].high+data[i].low+data[i].close)/3;
    cci.push((currentTP-sma)/(0.015*meanDev));
  }
  return cci;
}

function calculateBollinger(data, period=14){
  if(!data||data.length<period) return {upper:[], mid:[], lower:[]};
  const mid=[]; for(let i=period-1;i<data.length;i++){ const slice=data.slice(i-period+1,i+1).map(d=>d.close); mid.push(slice.reduce((a,b)=>a+b,0)/period);}
  const upper=[], lower=[];
  for(let i=period-1;i<data.length;i++){
    const slice=data.slice(i-period+1,i+1).map(d=>d.close);
    const avg=mid[i-(period-1)];
    const std=Math.sqrt(slice.map(p=>Math.pow(p-avg,2)).reduce((a,b)=>a+b,0)/period);
    upper.push(avg+2*std); lower.push(avg-2*std);
  }
  return {upper, mid, lower};
}

function calculateROC(prices, period=9){
  if(!prices||prices.length<period) return [];
  return prices.map((p,i)=>i<period?null:(p.close-prices[i-period].close)/prices[i-period].close*100);
}

function getTickHtml(cond){ return cond?'<span class="tick green">âœ”</span>':'<span class="tick red">âœ˜</span>'; }

async function getSymbolData(symbol, interval){
  const raw = await fetchPrices(symbol, interval);
  if(!raw||raw.length===0) return null;
  const ha=convertHA(raw);
  const price=raw[raw.length-1].close;
  const boll=ha.length>=14?calculateBollinger(ha):{upper:Array(ha.length).fill(null), mid:Array(ha.length).fill(null), lower:Array(ha.length).fill(null)};
  const rsi=ha.length>=14?calculateRSI(ha):Array(ha.length).fill(null);
  const rsiMA=rsi.length>=14?calculateMA(rsi,14):Array(rsi.length).fill(null);
  const cci=ha.length>=14?calculateCCI(ha):Array(ha.length).fill(null);
  const cciMA=cci.length>=14?calculateMA(cci,14):Array(cci.length).fill(null);
  const roc=ha.length>=9?calculateROC(ha,9):Array(ha.length).fill(null);
  const rocMA=roc.length>=5?calculateMA(roc,5):Array(roc.length).fill(null);
  const prevcci=cci.length>=2?cci.at(-2):null;
  const latest={
    bollUpper:boll.upper.at(-1), bollMid:boll.mid.at(-1), bollLower:boll.lower.at(-1),
    rsi:rsi.at(-1), rsiMA:rsiMA.at(-1),
    cci:cci.at(-1), cciMA:cciMA.at(-1),
    roc:roc.at(-1), rocMA:rocMA.at(-1)
  };
  let buy=false, sell=false;
  if([price, latest.bollMid, latest.rsi, latest.rsiMA, latest.cci].every(v=>v!=null)){
    buy=price>latest.bollMid && latest.rsi>latest.rsiMA && prevcci<0 && latest.cci>0;
    sell=price<latest.bollMid && latest.rsi<latest.rsiMA && prevcci>0 && latest.cci<0;
  }
  return {...latest, symbol, price, buySignal:buy, sellSignal:sell};
}

function buildReversedTable(){
  const tbody=document.getElementById('tableBody');
  tbody.innerHTML='';
  const indicators=["price","bollMid","bollUpper","bollLower","rsi","rsiMA","cci","cciMA","roc","rocMA","signal","tv"];
  for(const ind of indicators){
    const tr=document.createElement('tr');
    tr.id=`row_${ind}`;
    tr.innerHTML=`<td>${ind.toUpperCase()}</td>`+intervals.map(i=>`<td id="${ind}_${i}">â€”</td>`).join('');
    tbody.appendChild(tr);
  }
}

async function updateReversedTable(){
  for(const interval of intervals){
    const data=await getSymbolData(currentSymbol, interval);
    if(!data) continue;
    const mapData={
      price:data.price?.toFixed(5)??'â€”',
      bollMid:`${data.bollMid?.toFixed(5)??'â€”'} ${getTickHtml(data.price>data.bollMid)}`,
      bollUpper:data.bollUpper?.toFixed(5)??'â€”',
      bollLower:data.bollLower?.toFixed(5)??'â€”',
      rsi:`${data.rsi?.toFixed(2)??'â€”'} ${getTickHtml(data.rsi>data.rsiMA)}`,
      rsiMA:data.rsiMA?.toFixed(2)??'â€”',
      cci:`${data.cci?.toFixed(2)??'â€”'} ${getTickHtml(data.cci>0)}`,
      cciMA:data.cciMA?.toFixed(2)??'â€”',
      roc:`${data.roc?.toFixed(2)??'â€”'} ${getTickHtml(data.roc>data.rocMA)}`,
      rocMA:data.rocMA?.toFixed(2)??'â€”',
      signal:data.buySignal?'Ø®Ø±ÛŒØ¯ âœ…':data.sellSignal?'ÙØ±ÙˆØ´ âŒ':'Ø®Ù†Ø«ÛŒ',
      tv:`<a class="tv" href="https://www.tradingview.com/chart/?symbol=BINANCE:${currentSymbol}" target="_blank">Ù…Ø´Ø§Ù‡Ø¯Ù‡</a>`
    };
    for(const key in mapData){
      const td=document.getElementById(`${key}_${interval}`);
      if(td) td.innerHTML=mapData[key];
    }
  }
}

document.getElementById('symbolSelect').addEventListener('change', e=>{
  currentSymbol=e.target.value;
  buildReversedTable();
  updateReversedTable();
  updateFibo();
});

buildReversedTable();
updateReversedTable();
setInterval(updateReversedTable,30000);

//================ Ø¬Ø¯ÙˆÙ„ ÙÛŒØ¨ÙˆÙ†Ø§Ú†ÛŒ =================
function getColorByLevel(lvl){
  if(lvl===0.5) return "white";
  if(lvl>0.5){ const t=(lvl-0.5)/0.5; const r=255,g=Math.floor(255-t*155),b=Math.floor(255-t*155); return `rgb(${r},${g},${b})`; }
  else{ const t=lvl/0.5; const r=255,g=Math.floor(255*t),b=0; return `rgb(${r},${g},${b})`; }
}

function createFiboTable(){
  const levels=[0,0.236,0.382,0.5,0.618,0.786,1];
  const tbody=document.getElementById("fiboBody");
  tbody.innerHTML="";
  levels.forEach(lvl=>{
    const tr=document.createElement("tr");
    tr.style.color=getColorByLevel(lvl);
    const td1=document.createElement("td"); td1.textContent=(lvl*100).toFixed(1)+"%";
    const td2=document.createElement("td"); td2.id="lvl_"+lvl.toString().replace(".","_");
    tr.appendChild(td1); tr.appendChild(td2);
    tbody.appendChild(tr);
  });
}

async function updateFibo(){
  const tf=document.getElementById("tfFibo").value;
  const symbol=document.getElementById("symbolSelect").value;
  let limit=144;
  if(tf==="1d") limit=200;
  document.getElementById("fiboLength").textContent=`ğŸ“ Ø·ÙˆÙ„ Ø¯ÙˆØ±Ù‡: ${limit}`;
  const proxy="https://corsproxy.io/?";
  const url=`https://api.mexc.com/api/v3/klines?symbol=${symbol}&interval=${tf}&limit=${limit}`;
  document.getElementById("statusFibo").textContent="â³ Ø¯Ø± Ø­Ø§Ù„ Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§...";
  try{
    const res=await fetch(proxy+encodeURIComponent(url));
    const data=await res.json();
    if(!Array.isArray(data)||data.length<2) throw new Error("Ø¯Ø§Ø¯Ù‡ Ú©Ø§ÙÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯");
    const levels=[0,0.236,0.382,0.5,0.618,0.786,1];
    const highsC=data.map(d=>parseFloat(d[2]));
    const lowsC=data.map(d=>parseFloat(d[3]));
    const highC=Math.max(...highsC);
    const lowC=Math.min(...lowsC);
    const diffC=highC-lowC;
    const lastClose=parseFloat(data[data.length-1][4]);
    const prevClose=parseFloat(data[data.length-2][4]);
    
    levels.forEach(lvl=>{
      const price=highC-diffC*lvl;
      let mark="";
      if(prevClose<price && lastClose>price) mark="âœ…";
      else if(prevClose>price && lastClose<price) mark="âŒ";
      const td=document.getElementById("lvl_"+lvl.toString().replace(".","_"));
      td.textContent=price.toFixed(6)+" "+mark;
    });
    document.getElementById("statusFibo").textContent=`âœ… Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ Ø¨Ø±ÙˆØ² Ø´Ø¯Ù†Ø¯: ${new Date().toLocaleTimeString()}`;
  }catch(err){
    console.error(err);
    document.getElementById("statusFibo").textContent="âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡ ÛŒØ§ Ù…Ø­Ø§Ø³Ø¨Ù‡ ÙÛŒØ¨ÙˆÙ†Ø§Ú†ÛŒ.";
  }
}

createFiboTable();
updateFibo();
setInterval(updateFibo,30000);
</script>
</body>
</html>
