<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>تحلیل زنده - Heikin Ashi</title>

<style>
body { background: #111; color: #eee; font-family: sans-serif; text-align: center; padding: 10px; }
h1 { color: #00ff99; margin-bottom: 20px;font-size:16 }
#controls { max-width: 1000px; margin: auto 0 20px 0; text-align: center; }
#cardsContainer { max-width: 1000px; margin: auto; display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 15px; direction: rtl; }
.card { background: #1c1c1c; border-radius: 10px; padding: 15px; text-align: left; box-shadow: 0 0 10px #00ff99a0; font-size: 0.9rem; }
.card h2 { margin-top: 0; color: #00ff99; }
.indicator { margin: 5px 0; padding-bottom: 5px; border-bottom: 1px dashed #555; }
.buy { color: #00ff00; font-weight: bold; }
.sell { color: #ff3333; font-weight: bold; }
.neutral { color: #cccccc; font-weight: bold; }
.signal { margin-top: 10px; font-size: 1.1em; font-weight: bold; }
.tick { font-weight: bold; margin-right: 5px; }
.tick.green { color: #0f0; }
.tick.red { color: #f33; }
 /* MA */
     .ma200 { color: #ff9900; font-weight: bold; }
/* EMA */
.ema7 { color: #00ff99; font-weight: bold; }
.ema50 { color: #33ffcc; font-weight: bold; }
.ema100 { color: #66ff66; font-weight: bold; }

/* RSI */
.rsi { color: #ab47bc; font-weight: bold; }
.rsiMA { color: #FDD835; font-weight: bold; }

/* CCI */
.cci { color: #089981; font-weight: bold; }
.cciMA { color: #FDD835; font-weight: bold; }

/* ROC */
.roc { color: #2962FF; font-weight: bold; }
.rocMA { color: #ff9800; font-weight: bold; }

/* Bollinger Bands */
.bollUpper { color: #dbdbdb; font-weight: bold; }
.bollMid { color: #9c9c9c; font-weight: bold; }
.bollLower { color: #dbdbdb; font-weight: bold; }

/* MACD */
.macd { color: #2962FF; font-weight: bold; }
.macdSignal { color: #FF6D00; font-weight: bold; }
.macdHist { color: #ff00ff; font-weight: bold; }

/* Ichimoku */
.tenkan { color: #2962ff; font-weight: bold; }
.kijun { color: #b71c1c; font-weight: bold; }
.senkouAc { color: #a5d6a8; font-weight: bold; }
.senkouBc { color: #ef9a9b; font-weight: bold; }
.senkouA { color: #a5d6a7; font-weight: bold; }
.senkouB { color: #ef9a9a; font-weight: bold; }
.chikou { color: #ffa726; font-weight: bold; }
</style>
</head>
<body>
<div id="countdown">⏳ زمان باقیمانده کندل محاسبه می‌شود...</div>
<h1>تحلیل زنده Heikin Ashi</h1>
<!-- لینک برگشت به صفحه اصلی -->
<div id="homeLink" style="margin: 20px; text-align: center;">
  <a href="index.html" 
     style="color:#0ff; font-size:16px; font-weight:bold; text-decoration:none;">
برگشت به صفحه اصلی
</a>
</div>

<div id="controls">
  <label for="timeframeSelect">تایم فریم: </label>
  <select id="timeframeSelect" aria-label="انتخاب تایم فریم">
    <option value="15m" >۱۵ دقبقه</option>
   <option value="30m" >۳۰ دقیقه</option>
    <option value="1h" selected>۱ ساعته</option>
    <option value="4h">۴ ساعته</option>
     <option value="8h">۸ ساعت</option>
    <option value="1d">روزانه</option>
  </select>
</div>

<div id="cardsContainer">در حال دریافت داده‌ها...</div>

<script>
const symbols = ["BLUMUSDT","BTCUSDT","ETHUSDT","SOLUSDT","SUIUSDT","XRPUSDT","NEARUSDT","CAKEUSDT","ASTERUSDT","ADAUSDT","CRVUSDT","XLMUSDT","DOGEUSDT","TRXUSDT","PUMPUSDT","TONUSDT"];

async function fetchPrices(symbol, interval = "60m") {
  try {
    const url = `https://api.mexc.com/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=200`;
    const proxy = "https://corsproxy.io/?";
    const res = await fetch(proxy + encodeURIComponent(url));
    if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
    const data = await res.json();
    if (!Array.isArray(data) || data.length === 0) throw new Error('پاسخ API نامعتبر یا خالی است');
    return data.map(c => ({
      time: new Date(c[0]),
      open: parseFloat(c[1]),
      high: parseFloat(c[2]),
      low: parseFloat(c[3]),
      close: parseFloat(c[4]),
      volume: parseFloat(c[5])
    }));
  } catch(e) { console.error(`خطا در دریافت داده برای ${symbol}:`, e.message); return null; }
}

// تبدیل کندل اصلی به Heikin-Ashi
function convertHeikinAshi(data){
  if(!data || data.length===0) return [];
  const ha = [];
  for(let i=0;i<data.length;i++){
    const o = data[i].open, h=data[i].high, l=data[i].low, c=data[i].close;
    if(i===0){
      ha.push({open:(o+c)/2, high:h, low:l, close:(o+h+l+c)/4, volume:data[i].volume});
    } else {
      const prev=ha[i-1];
      const haClose = (o+h+l+c)/4;
      const haOpen = (prev.open+prev.close)/2;
      const haHigh = Math.max(h, haOpen, haClose);
      const haLow = Math.min(l, haOpen, haClose);
      ha.push({open:haOpen, high:haHigh, low:haLow, close:haClose, volume:data[i].volume});
    }
  }
  return ha;
}

// محاسبه زمان باقیمانده از تایم‌فریم
function tfToMinutes(tf){
  switch(tf){
    case "15m": return 15;
    case "30m": return 30;
    case "60m": return 60;
    case "4h": return 240;
    case "8h": return 480;
    case "1d": return 1440;
    default: return 60;
  }
}
function updateCountdown(tf){
  const tfMinutes = tfToMinutes(tf);
  const now = Date.now();
  const tfMillis = tfMinutes * 60 * 1000;
  const startOfCandle = Math.floor(now / tfMillis) * tfMillis;
  const endOfCandle = startOfCandle + tfMillis;
  const remaining = endOfCandle - now;
  const hrs = Math.floor(remaining / (1000*60*60));
  const mins = Math.floor((remaining % (1000*60*60)) / (1000*60));
  const secs = Math.floor((remaining % (1000*60)) / 1000);
  document.getElementById("countdown").innerText =
    `⏳ زمان باقیمانده: ${hrs} ساعت ${mins} دقیقه ${secs} ثانیه`;
}
let currentInterval='60m';
setInterval(()=>updateCountdown(currentInterval),1000);
// ================= توابع محاسبه =================
function calculateEMAArray(values, period){
  if(!values || values.length<period) return Array(values?values.length:0).fill(null);
  const k = 2/(period+1);
  const out = [];
  let sum = 0;
  for(let i=0;i<values.length;i++){
    const v = values[i];
    if(i<period-1){ out.push(null); sum += (v??0); continue; }
    if(i===period-1){ sum += (v??0); out.push(sum/period); continue; }
    const prev = out[i-1];
    const val = (v==null)?prev:v;
    out.push(val*k + prev*(1-k));
  }
  return out;
}

function calculateMA(values, period){
  if(!values || values.length<period) return [];
  const ma=[];
  for(let i=0;i<values.length;i++){
    if(i<period-1||values[i]==null) ma.push(null);
    else{
      const slice=values.slice(i-period+1,i+1).filter(v=>v!=null);
      ma.push(slice.reduce((a,b)=>a+b,0)/slice.length);
    }
  }
  return ma;
}

function calculateRSI(data, period=14){
  if(!data || data.length<period+1) return [];
  const gains=[], losses=[];
  for(let i=1;i<data.length;i++){
    const diff = data[i].close - data[i-1].close;
    gains.push(diff>0?diff:0);
    losses.push(diff<0?-diff:0);
  }
  let avgGain=gains.slice(0,period).reduce((a,b)=>a+b,0)/period;
  let avgLoss=losses.slice(0,period).reduce((a,b)=>a+b,0)/period;
  const rsi=[];
  for(let i=0;i<period;i++) rsi.push(null);
  for(let i=period;i<gains.length;i++){
    avgGain=(avgGain*(period-1)+gains[i])/period;
    avgLoss=(avgLoss*(period-1)+losses[i])/period;
    const rs = avgGain/(avgLoss||1);
    rsi.push(100-(100/(1+rs)));
  }
  return rsi;
}

function calculateCCI(data, period=14){
  if(!data || data.length<period) return [];
  const tp = data.map(d=>(d.high+d.low+d.close)/3);
  const sma=[];
  for(let i=period-1;i<tp.length;i++){
    const slice = tp.slice(i-period+1,i+1);
    sma.push(slice.reduce((a,b)=>a+b,0)/period);
  }
  const cci=[];
  for(let i=0;i<period-1;i++) cci.push(null);
  for(let i=period-1;i<tp.length;i++){
    const mean=sma[i-(period-1)];
    const slice=tp.slice(i-period+1,i+1);
    const meanDev=slice.reduce((a,b)=>a+Math.abs(b-mean),0)/period||1;
    cci.push((tp[i]-mean)/(0.015*meanDev));
  }
  return cci;
}

function calculateBollinger(data, period=14){
  if(!data || data.length<period) return {upper:[], mid:[], lower:[]};
  const mid=[];
  for(let i=period-1;i<data.length;i++){
    const slice=data.slice(i-period+1,i+1).map(d=>d.close);
    mid.push(slice.reduce((a,b)=>a+b,0)/period);
  }
  const upper=[], lower=[];
  for(let i=period-1;i<data.length;i++){
    const slice=data.slice(i-period+1,i+1).map(d=>d.close);
    const avg=mid[i-(period-1)];
    const std=Math.sqrt(slice.map(p=>Math.pow(p-avg,2)).reduce((a,b)=>a+b,0)/period);
    upper.push(avg+2*std);
    lower.push(avg-2*std);
  }
  return {upper, mid, lower};
}

function calculateMACD(prices, fast=12, slow=26, signal=9){
  const closeArray = prices.map(p=>p.close);
  const emaFast = calculateEMAArray(closeArray, fast);
  const emaSlow = calculateEMAArray(closeArray, slow);
  const macdLine = emaFast.map((v,i)=>(v==null||emaSlow[i]==null)?null:(v-emaSlow[i]));
  const signalLine = calculateEMAArray(macdLine, signal);
  const histogram = macdLine.map((v,i)=>(v==null||signalLine[i]==null)?null:(v-signalLine[i]));
  return {macdLine, signalLine, histogram};
}

function calculateROC(prices, period=9){
  if(!prices || prices.length<period) return [];
  const roc=[];
  for(let i=0;i<prices.length;i++){
    if(i<period){ roc.push(null); continue; }
    roc.push((prices[i].close-prices[i-period].close)/prices[i-period].close*100);
  }
  return roc;
}

function calculateIchimoku(data){
  if(!data || data.length<52) return {tenkan:[], kijun:[], senkouA:[], senkouB:[], chikou:[]};
  const tenkan=[], kijun=[], senkouA=[], senkouB=[], chikou=[];
  for(let i=0;i<data.length;i++){
    tenkan.push(i>=8 ? (Math.max(...data.slice(i-8,i+1).map(d=>d.high))+Math.min(...data.slice(i-8,i+1).map(d=>d.low)))/2 : null);
    kijun.push(i>=25 ? (Math.max(...data.slice(i-25,i+1).map(d=>d.high))+Math.min(...data.slice(i-25,i+1).map(d=>d.low)))/2 : null);
    senkouA.push(i>=25 ? (tenkan[i]+kijun[i])/2 : null);
    senkouB.push(i>=51 ? (Math.max(...data.slice(i-51,i+1).map(d=>d.high))+Math.min(...data.slice(i-51,i+1).map(d=>d.low)))/2 : null);
    chikou.push(i>=26 ? data[i-26].close : null);
  }
  return {tenkan,kijun,senkouA,senkouB,chikou};
}

// نمایش Tick سبز/قرمز
function getTickHtml(condition){ return condition?'<span class="tick green">✔</span>':'<span class="tick red">✘</span>'; }

// دریافت داده‌ها و نمایش کارت‌ها
async function getSymbolData(symbol, interval){
  const raw = await fetchPrices(symbol, interval);
  if(!raw || raw.length<200) return null;
  const ha = convertHeikinAshi(raw); // اندیکاتورها روی هیکین‌آشی
  const price = raw[raw.length-1].close; // قیمت واقعی برای چاپ و شرط سیگنال

  const ema7 = calculateEMAArray(ha.map(d=>d.close), 7);
  const ema50 = calculateEMAArray(ha.map(d=>d.close), 50);
  const ema100 = calculateEMAArray(ha.map(d=>d.close), 100);
      const ma200 = calculateMA(ha.map(p=>p.close),200);
  const boll = calculateBollinger(ha);
  const rsi = calculateRSI(ha);
  const rsiMA = calculateMA(rsi,9);
  const cci = calculateCCI(ha);
  const cciMA = calculateMA(cci,9);
  const macd = calculateMACD(ha);
  const roc = calculateROC(ha,9);
  const rocMA = calculateMA(roc,5);
  const ichimoku = calculateIchimoku(ha);
  const prevcci=cci.at(-2)
  const latest = {
    ema7: ema7.at(-1), ema50: ema50.at(-1), ema100: ema100.at(-1),
    ma200: ma200[ma200.length-1],
    bollUpper: boll.upper.at(-1), bollMid: boll.mid.at(-1), bollLower: boll.lower.at(-1),
    rsi: rsi.at(-1), rsiMA: rsiMA.at(-1),
    cci: cci.at(-1), cciMA: cciMA.at(-1),
    macd: macd.macdLine.at(-1), macdSignal: macd.signalLine.at(-1), macdHist: macd.histogram.at(-1),
    roc: roc.at(-1), rocMA: rocMA.at(-1),
    ichimoku: { tenkan: ichimoku.tenkan.at(-1), kijun: ichimoku.kijun.at(-1),
 senkouAc: ichimoku.senkouA.at(-25),
 senkouBc: ichimoku.senkouB.at(-25), 
senkouA: ichimoku.senkouA.at(-1),
 senkouB: ichimoku.senkouB.at(-1) }
  };

  let buy=false, sell=false;
  if([price, latest.ema7, latest.bollMid, latest.rsi, latest.rsiMA, latest.cci].every(v=>v!=null)){
    const priceBuy = price>latest.ema7 && price>latest.bollMid;
    const rsiBuy = latest.rsi>latest.rsiMA;
    const cciBuy =prevcci<0 && latest.cci>0;
    const priceSell = price<latest.ema20 && price<latest.bollMid;
    const rsiSell = latest.rsi<latest.rsiMA;
    const cciSell = prevcci>0 && latest.cci<0;
    buy = priceBuy && rsiBuy && cciBuy;
    sell = priceSell && rsiSell && cciSell;
  }
  return {...latest, symbol, price, buySignal:buy, sellSignal:sell};
}

// اجرا و نمایش کارت‌ها
async function asyncPool(poolLimit,array,iteratorFn){
  const ret=[], executing=[];
  for(const item of array){
    const p=Promise.resolve().then(()=>iteratorFn(item));
    ret.push(p);
    if(poolLimit<=array.length){
      const e=p.then(()=>executing.splice(executing.indexOf(e),1));
      executing.push(e);
      if(executing.length>=poolLimit) await Promise.race(executing);
    }
  }
  return Promise.all(ret);
}

async function updateAll(){
  const container=document.getElementById("cardsContainer");
  container.innerHTML="در حال دریافت داده‌ها...";
  try{
    const results = await asyncPool(5,symbols,s=>getSymbolData(s,currentInterval));
    container.innerHTML="";
    results.forEach(data=>{
      if(!data){ container.innerHTML+=`<div class="card"><h2>خطا در دریافت داده</h2></div>`; return; }
      container.innerHTML+=`
<div class="card">
<h2>${data.symbol}</h2>
<div class="indicator">💰 قیمت واقعی: ${data.price.toFixed(5)} USD</div>
<div class="indicator">📈 RSI: ${data.rsi?.toFixed(2) ?? '—'} <span class="rsiMA">MA(14): ${data.rsiMA?.toFixed(2) ?? '—'} ${getTickHtml(data.rsi>data.rsiMA)}</span></div>
<div class="indicator">📈 CCI: ${data.cci?.toFixed(2) ?? '—'} <span class="cciMA">MA(14): ${data.cciMA?.toFixed(2) ?? '—'} ${getTickHtml(data.cci>0)}</span></div>
<div class="indicator">📈 ROC: ${data.roc?.toFixed(2) ?? '—'} <span class="rocMA">MA(5): ${data.rocMA?.toFixed(2) ?? '—'} ${getTickHtml(data.roc>data.rocMA)}</span></div>
<div class="indicator ema7">🔸 EMA7: ${data.ema7?.toFixed(5) ?? '—'} ${getTickHtml(data.price>data.ema7)}</div>
<div class="indicator"><span class="ema50">EMA50: ${data.ema50?.toFixed(5) ?? '—'}</span> | <span class="ema100"> EMA100: ${data.ema100?.toFixed(5) ?? '—'}</span></div>
  <div class="indicator ma200">🏁 MA200: ${data.ma200?.toFixed(5) ?? '—'} ${getTickHtml(data.price>data.ma200)}</div>
<div class="indicator bollMid">🔘 BB Mid: ${data.bollMid?.toFixed(5) ?? '—'} ${getTickHtml(data.price>data.bollMid)}</div>
<div><span class="bollUpper">BB Upper: ${data.bollUpper?.toFixed(5) ?? '—'}</span> | <span class="bollLower"> BB Lower: ${data.bollLower?.toFixed(5) ?? '—'}</span></div>
<div class="indicator"><span class="macd">MACD: ${data.macd?.toFixed(4) ?? '—'}</span> | <span class="macdSignal"> Signal: ${data.macdSignal?.toFixed(4) ?? '—'} ${getTickHtml(data.macd>data.macdSignal)}</span><br><span class="macdHist">Hist: ${data.macdHist?.toFixed(4) ?? '—'}</span></div>
<div class="indicator"><span class="tenkan">Tenkan: ${data.ichimoku.tenkan?.toFixed(4) ?? '—'}</span> | <span class="kijun"> Kijun: ${data.ichimoku.kijun?.toFixed(4) ?? '—'} ${getTickHtml(data.price>data.ichimoku.tenkan)}</span>
<br>
<span class="senkouAC">SenkouAC: ${data.ichimoku.senkouAc?.toFixed(4) ?? '—'}</span> | <span class="senkouBC"> SenkouBC: ${data.ichimoku.senkouBc?.toFixed(4) ?? '—'} ${getTickHtml(data.ichimoku.senkouAc>data.ichimoku.senkouBc)}</span>
<br>
<span class="senkouA">SenkouA: ${data.ichimoku.senkouA?.toFixed(4) ?? '—'}</span> | <span class="senkouB"> SenkouB: ${data.ichimoku.senkouB?.toFixed(4) ?? '—'} ${getTickHtml(data.ichimoku.senkouA>data.ichimoku.senkouB)}</span></div>

<div class="signal ${data.buySignal?"buy":data.sellSignal?"sell":"neutral"}">سیگنال: ${data.buySignal?"خرید ✅":data.sellSignal?"فروش ❌":"خنثی"}</div>

    <!-- 🔗 لینک به تریدینگ ویو -->
  <div class="tv-link" style="margin-top:8px; text-align:center;">
    <a href="https://www.tradingview.com/chart/?symbol=BINANCE:${data.symbol}" 
       target="_blank" 
       style="color:#0ff; font-size:14px; text-decoration:underline;">
                               مشاهده ${data.symbol} در تریدینگ‌ویو
    </a>
  </div>
  
  
  
</div>`;
    });
  } catch(e){ container.innerHTML=`<div class="card"><h2>خطای کلی در دریافت داده‌ها</h2></div>`; console.error(e); }
}

document.getElementById('timeframeSelect')?.addEventListener('change', e=>{ currentInterval=e.target.value; updateAll(); });
updateAll();
setInterval(()=>updateAll(),60000);

</script>
</body>

</html>